"""Beheren van domicilieringsbestanden"""

# global dict which defines the exporters to be used by type of direct debit batch
# this dict is filled from within the connector modules
direct_debit_export = {}

import collections
import copy
import datetime
import logging
import os
import StringIO
import itertools
import six
import re
import csv

from stdnum import iban
from cStringIO import StringIO as cStringIO

import sqlalchemy.types
from sqlalchemy import orm, sql, event, schema
from sqlalchemy.ext.declarative import declared_attr


from camelot.core.orm import Entity, using_options, ManyToOne
from camelot.model.authentication import end_of_times
from camelot.model import type_and_status, party
from camelot.admin.entity_admin import EntityAdmin
from camelot.admin.object_admin import ObjectAdmin
from camelot.admin.action import Action
from camelot.view.art import ColorScheme
from camelot.view import action_steps
from camelot.view.controls import delegates
from camelot.view import forms
from camelot.core.utils import ugettext_lazy as _
from camelot.core.exception import UserException
from camelot.core.qt import QtGui
from camelot.core.resources import resource_string
import camelot.types

from vfinance.admin.vfinanceadmin import VfinanceAdmin
from . import validation
from .invoice import InvoiceItem
from .statusmixin import BankStatusMixin, BankStatusAdmin, BankRelatedStatusAdmin, status_form_actions
from .constants import (functional_settings, direct_debit_types,
                        direct_debit_batch_statuses, direct_debit_sequence_types,
                        direct_debit_result_types, bank_account_types)

logger = logging.getLogger('vfinance.model.bank.direct_debit')

#
# Direct debit details are generated by the direct debit batch
# and fed to the connectors that create files
# to communicate with the bank
#
direct_debit_detail = collections.namedtuple('direct_debit_detail',
                                             ['end_to_end_id', 'amount', 'bic', 'iban', 'remark_1', 'remark_2',
                                              'mandate_id', 'mandate_signature_date', 'mandate_sequence_type',
                                              'debtor_name', 'collection_date', 'original_mandate_id'])

#
# Direct debit status reports are generated by the connectors and fed to
# the direct debit batches
#
direct_debit_status_report = collections.namedtuple('direct_debit_status_report',
                                                    ['payment_group_id', 'end_to_end_id', 'amount', 'book_date', 'result', 'reason'])

class BankIdentifierCode( Entity ):
    """The BIC codes of various banks"""
    using_options( tablename='bank_identifier_code' )
    name = schema.Column( sqlalchemy.types.Unicode(128), nullable=False, index=True )
    code = schema.Column( sqlalchemy.types.Unicode(11), nullable=False, index=True )
    country = schema.Column( sqlalchemy.types.Unicode(2), nullable=False, index=True )

    def __unicode__(self):
        return self.code or '...'

    class Admin( EntityAdmin ):
        verbose_name = _('Bank Identifier Code')
        list_display = ['country', 'code', 'name']
        list_actions = []

class LazyTable(dict):

    def __init__(self, name):
        self._name = name
        super(LazyTable, self).__init__()

    def __getitem__(self, requested_key):
        if not len(self):
            table_file = cStringIO(resource_string('vfinance', os.path.join('art', 'tables', self._name)))
            mapping_file = csv.DictReader( table_file )
            for line in mapping_file:
                super(LazyTable, self).__setitem__((line['from'],line['trough']), (line['bic'], line['bank_nl'], line['bank_fr'], line['bank_de'], line['bank_en']))

        return super(LazyTable, self).__getitem__(requested_key)

class IbanBicMixin(object):
    _MAPPING_TABLE = None

    def bank_digits_iban(self):
        if self.iban:
            return re.sub('[^0-9]', '', self.iban)[2:5]
        return '-1'

    @classmethod
    def get_mapping_table(cls):
        if cls._MAPPING_TABLE is None:
            logger.info('Initializing table')
            cls._MAPPING_TABLE = LazyTable('iban_bic_current_mapping.csv')
        cls._MAPPING_TABLE[('000', '000')]
        return cls._MAPPING_TABLE

    def get_bic_code(self):
           # Link with iban -> bic mappings for belgian iban-codes: http://www.bnb.be/pub/09_00_00_00_00/09_06_00_00_00/09_06_02_00_00.htm?l=en
           table = self.get_mapping_table()
           for _from, _trough in table.keys():
               if int(_from) <= int(self.bank_digits_iban()) <= int(_trough):
                   return table[(_from, _trough)][0]
           return ''

    def get_iban(self):
        return self.iban

    def set_iban(self, iban):
        self.iban = iban
        bic = self.get_bic_code()
        bic_clean = re.sub(' ', '', bic)
        session = orm.object_session(self)
        if bic and self.iban[0:2].upper() == 'BE':
            self.bank_identifier_code = session.query(BankIdentifierCode).filter(BankIdentifierCode.code==bic_clean).first()
        if self.iban is None:
            self.bank_identifier_code = None

    _iban = property(get_iban, set_iban)

class AbstractBankAccount(IbanBicMixin):
    from_date = schema.Column( sqlalchemy.types.Date(), nullable=False, default=datetime.date.today )
    thru_date = schema.Column( sqlalchemy.types.Date(), nullable=False, default=end_of_times )
    described_by = schema.Column( camelot.types.Enumeration(bank_account_types), nullable=False, default='sepa' )
    mapping_table = None

    @declared_attr
    def bank_identifier_code_id(self):
        return schema.Column('bank_identifier_code_id',
                             sqlalchemy.types.Integer(),
                             schema.ForeignKey(BankIdentifierCode.id,
                                               onupdate='cascade',
                                               ondelete='restrict'),
                             nullable=True,
                             index=True)

    @declared_attr
    def bank_identifier_code(self):
        return orm.relationship(BankIdentifierCode)

    iban = schema.Column( sqlalchemy.types.Unicode(4+30), nullable=False )

    def is_valid( self ):
        if self.iban is None:
            return False
        if self.described_by == 'local':
            return validation.ogm(self.iban)
        else:
            if self.bank_identifier_code_id is None:
                return False
            return validation.iban(self.iban)[0]

    def __unicode__(self):
        return self.iban or '...'

    class Admin( EntityAdmin ):

        class BankingNumberValidator(QtGui.QValidator):

            def validate(self, qtext, position):
                ptext = six.text_type(qtext)
                ptext_clean = re.sub('[.\-/ ]', '', ptext)

                if qtext == '':
                    return (QtGui.QValidator.Acceptable, 0)

                if iban.is_valid(ptext_clean):
                    ptext = iban.format(ptext_clean)
                    qtext.clear()
                    qtext.insert(0, ptext)
                    return (QtGui.QValidator.Acceptable, len(qtext))

                return (QtGui.QValidator.Intermediate, position)

        verbose_name = _('Bank Account')
        list_display = ['described_by', '_iban', 'bank_identifier_code', 'from_date', 'thru_date']
        list_actions = []
        field_attributes = {'_iban':{'validator': BankingNumberValidator()},}

class DirectDebitMandate( Entity, AbstractBankAccount ):
    """A SEPA style mandate to debit a customer account
    """
    using_options(tablename='financial_clearing_mandate')
    identification = schema.Column(sqlalchemy.types.Unicode(35), nullable=False)
    financial_agreement = ManyToOne('vfinance.model.financial.agreement.FinancialAgreement', onupdate='cascade', ondelete='set null')
    financial_account = ManyToOne('vfinance.model.financial.account.FinancialAccount', onupdate='cascade', ondelete='set null')
    hypotheek = ManyToOne('vfinance.model.hypo.hypotheek.Hypotheek', onupdate='cascade', ondelete='set null')
    date = schema.Column( sqlalchemy.types.Date(), nullable=False, default=datetime.date.today )
    document = schema.Column( camelot.types.File( upload_to=os.path.join('financial', 'direct_debit_mandate', 'document') ), nullable=True )
    described_by = schema.Column( camelot.types.Enumeration(direct_debit_types), nullable=False, default='core' )
    # this is the first sequence type when using this mandate, to be used to be
    # able to make rcur direct debits when the mandate is imported, and there is
    # no reference to the first direct debit
    sequence_type = schema.Column(camelot.types.Enumeration(direct_debit_sequence_types), nullable=False, default='FRST')

    def get_default_identification(self):
        if self.hypotheek:
            return self.hypotheek.full_number
        if self.financial_agreement:
            return self.financial_agreement.code

    def get_identification( self ):
        """:return: the identification used to communicate with the clearinghouse"""
        if not self.identification:
            return None
        return self.identification.strip()

    class Admin(AbstractBankAccount.Admin, BankRelatedStatusAdmin):
        verbose_name = _('Direct Debit Mandate')
        list_display = ['date', 'described_by', 'identification', '_iban', 'from_date', 'thru_date', 'modification_of', 'sequence_type']
        list_filter = ['described_by']
        form_display = ['date', 'identification', 'bank_identifier_code', '_iban', 'document', 'described_by', 'from_date', 'thru_date', 'sequence_type']
        field_attributes = copy.copy(AbstractBankAccount.Admin.field_attributes)
        field_attributes['identification'] = {'background_color':lambda mandate:{True:None, False:ColorScheme.yellow_1}[validation.ogm(mandate.identification)]}
        field_attributes['date'] = {'name': 'Signature date',}

        def get_related_status_object(self, obj):
            if obj is not None:
                return obj.financial_account
            return None

DirectDebitMandate.modification_of = ManyToOne(DirectDebitMandate,
                                               nullable=True,
                                               ondelete='restrict',
                                               onupdate='cascade')

class ExportDirectDebitBatch(Action):

    verbose_name = _('Export')

    def model_run(self, model_context):
        for batch in model_context.get_selection():
            yield action_steps.UpdateProgress(text=u'Export batch {0.id}'.format(batch))
            if len(batch.composed_of) == 0:
                raise UserException(u'Batch contains no items')
            if batch.current_status !=  'verified':
                raise UserException(u'Batch is not yet verified')
            if batch.export != None:
                raise UserException(u'Batch has been exported before')
            exporter = direct_debit_export.get(batch.described_by)
            if exporter is None:
                raise UserException(u'No exporter found for {0.described_by} batch'.format(batch))
            dom_mapper = orm.object_mapper(batch)
            export_property = dom_mapper.get_property('export')
            storage = export_property.columns[0].type.storage
            stream = StringIO.StringIO()
            details = list(batch.generate_details())
            for step in exporter(stream, batch.batch, batch.id, batch.datum_opmaak, batch.spildatum, details):
                yield step
            stream.seek(0)
            spildatum = batch.spildatum
            filename = '%s-%s-%s-%s-'%(spildatum.year, spildatum.month, spildatum.day, batch.referentie)
            batch.export = storage.checkin_stream(filename , '.txt', stream)
        yield action_steps.FlushSession(model_context.session)

    def get_state(self, model_context):
        state = super(ExportDirectDebitBatch, self).get_state(model_context)
        for batch in model_context.get_selection():
            if batch is not None:
                if (batch.current_status != 'verified') or (batch.export is not None):
                    state.enabled = False
        return state

class CloseOptions(object):
    
    def __init__(self):
        self.collected_amount = 0
    
    class Admin(ObjectAdmin):
        list_display = ['collected_amount']
        field_attributes = {'collected_amount':{'editable':True,
                                                'delegate':delegates.FloatDelegate,
                                                'decimal':True}
                            }

class CloseDirectDebitBatch(type_and_status.ChangeStatus):
    
    def __init__(self):
        super(CloseDirectDebitBatch, self).__init__('closed', _('Close'))
    
    def model_run(self, model_context):
        for batch in model_context.get_selection():
            amount = 0
            for direct_debit_item in batch.composed_of:
                if direct_debit_item.status == 'pending':
                    raise UserException('Direct debit batch has pending items')
                if direct_debit_item.status == 'accepted':
                    amount += direct_debit_item.amount
            options = CloseOptions()
            yield action_steps.ChangeObject(options)
            if options.collected_amount != amount:
                raise UserException('The collected amount does not match the accepted items')
        for step in super(CloseDirectDebitBatch, self).model_run(model_context):
            yield step

    def get_state(self, model_context):
        state = super(CloseDirectDebitBatch, self).get_state(model_context)
        for batch in model_context.get_selection():
            if batch is not None:
                if batch.current_status not in ('verified', 'canceled'):
                    state.enabled = False
        return state

class NewOptions(object):
    
    def __init__(self):
        self.collection_date = datetime.date.today()
    
    class Admin(ObjectAdmin):
        verbose_name = _('New direct debit batch options')
        list_display = ['collection_date']
        field_attributes = {'collection_date':{'editable':True,
                                                'delegate':delegates.DateDelegate}
                            }

class NewDirectDebitBatch(Action):
    
    verbose_name = _('New from reject')
    tooltip = _('Create a new batch with rejected items')
    
    def model_run(self, model_context):
        options = NewOptions()
        yield action_steps.ChangeObject(options)
        with model_context.session.begin():
            for batch in model_context.get_selection():
                new_batch = DirectDebitBatch.get_open_direct_debit_batch(described_by=batch.described_by,
                                                                         spildatum=options.collection_date,
                                                                         batch=batch.batch)
                for batch_item in batch.composed_of:
                    if batch_item.status == 'rejected':
                        for batch_invoice_item in batch_item.collection_of:
                            invoice_item = batch_invoice_item.of
                            mandate = invoice_item.get_mandate()
                            new_batch.append_invoice_items(mandate,
                                                           options.collection_date,
                                                           batch_item.item_description,
                                                           [invoice_item]
                                                           )
                        


class DirectDebitBatch(Entity, BankStatusMixin):
    using_options(tablename='hypo_domiciliering', order_by=['spildatum', 'id'])
    batch = schema.Column( camelot.types.Enumeration(functional_settings),
                   nullable=False,
                   default='direct_debit_batch_1' )
    described_by = schema.Column(camelot.types.Enumeration(direct_debit_types), nullable=False, default='core')
    status = type_and_status.Status( enumeration=direct_debit_batch_statuses )
    mededeling1  =  schema.Column(sqlalchemy.types.Unicode(15), nullable=True, default=lambda:'%s/%s/%s'%(datetime.date.today().day, datetime.date.today().month, datetime.date.today().year))
    referentie  =  schema.Column(sqlalchemy.types.Unicode(10), nullable=True, default=lambda:'%s-%s'%(datetime.date.today().month, datetime.date.today().year))
    spildatum  =  schema.Column(sqlalchemy.types.Date(), nullable=False, default=datetime.date.today)
    datum_opmaak  =  schema.Column(sqlalchemy.types.Date(), nullable=False, default=datetime.date.today)
    export = schema.Column( camelot.types.File( upload_to='direct_debit_exports' ), nullable=True )

    @property
    def note(self):
        return None

    def is_verifiable(self):
        return True

    def __unicode__(self):
        return u'%s %s, %s [%s]'%(self.batch, self.referentie, self.spildatum, self.current_status)

    @classmethod
    def handle_status_reports(cls, session, status_reports):
        """
        Handle a `direct_debit_status_report` iterator.  An exception will be raised
        if there is a status report concerning a batch that is not yet verified or
        has been closed.

        :return: a `DirectDebitItem` iterator if the status report could be handled,
            `None` if there was no item found that corresponds to the status report.
        """
        for status_report in status_reports:
            query = session.query(DirectDebitItem)
            query = query.filter(DirectDebitItem.id==int(status_report.end_to_end_id))
            query = query.filter(DirectDebitItem.part_of_id==int(status_report.payment_group_id))
            item = query.first()
            if item is not None:
                if item.part_of.current_status != 'verified':
                    raise UserException('Direct debit batch {0.id} is not verified'.format(item.part_of))
                item.status = status_report.result
            yield item

    @classmethod
    def get_open_direct_debit_batch(cls, described_by, spildatum=None, batch=None):
        """
        :param described_by: the type of direct debit batch, 'local', 'core' or 'b2b'

        :param spildatum: if not None, return a Direct Debit object with spildatum no later
        than requested

        :param batch: in None, use 'direct_debit_batch_1'
        """
        batch = batch or 'direct_debit_batch_1'
        query = cls.query.filter_by(current_status='draft', batch=batch, described_by=described_by)
        if spildatum:
            query = query.filter( DirectDebitBatch.spildatum <= spildatum )
        # order by id, to get the last created one, making unittests easier
        domicil = query.order_by( cls.datum_opmaak.desc(), cls.id.desc() ).first()
        if not domicil:
            domicil = cls(spildatum = spildatum or datetime.date.today(),
                          batch = batch, described_by=described_by)
        return domicil

    def append_item(self, mandate, at, description):
        """Create a new direct debit item for a mandate. Raises an exception when
        there is a pending `FRST` item for this mandate.
        
        :param mandate: the clearing mandate to be used
        :param at: the date at which the invoice items should be collected
        :param description:the description as it will appear to the debtor
        :return: a new :class:`DirectDebitItem`
        """
        same_mandate_query = orm.object_session(self).query(DirectDebitItem)
        same_mandate_query = same_mandate_query.join(DirectDebitItem.part_of)
        same_mandate_query = same_mandate_query.filter(DirectDebitItem.mandated_by==mandate)
        same_mandate_query = same_mandate_query.filter(DirectDebitBatch.current_status!='canceled')
        same_mandate_query = same_mandate_query.filter(DirectDebitBatch.id!=self.id)
        
        frst_items_query = same_mandate_query.filter(DirectDebitItem.sequence_type=='FRST')
        frst_items_query = frst_items_query.filter(sql.or_(DirectDebitItem.status=='pending',
                                                            DirectDebitBatch.current_status!='closed'))
        if frst_items_query.count() > 0:
            pending_first_item = frst_items_query.first()
            raise UserException('FRST direct debit item {1.id} of batch {1.part_of_id} for mandate {0.identification} is still pending'.format(mandate, pending_first_item),
                                title = u'Cannot append {0} to batch {1.id}'.format(description, self),
                                detail = u'Batch {0.part_of_id} was created on {0.part_of.datum_opmaak}\nBatch {1.id} was created on {1.datum_opmaak}'.format(pending_first_item, self),
                                resolution = u'Either close batch {0.part_of_id} or append this item to batch {0.part_of_id}'.format(pending_first_item)
                                )

        last_frst_item_query = same_mandate_query.filter(DirectDebitBatch.current_status=='closed')
        last_frst_item_query = last_frst_item_query.filter(DirectDebitItem.status!='pending')
        last_frst_item_query = last_frst_item_query.order_by(DirectDebitItem.request_at.desc())
        last_frst_item_query = last_frst_item_query.filter(DirectDebitItem.sequence_type=='FRST')
        last_frst_item = last_frst_item_query.first()
        
        sequence_type = mandate.sequence_type
        if last_frst_item is not None:
            if last_frst_item.status == 'accepted':
                sequence_type = 'RCUR'

        direct_debit_item = DirectDebitItem(part_of=self,
                                            mandated_by=mandate,
                                            sequence_type=sequence_type,
                                            item_description=description,
                                            request_at=max(at, self.spildatum))
        return direct_debit_item

    def append_invoice_items(self, mandate, at, description, invoice_items):
        """
        Append a number of invoice items as a single direct debit item.  If there
        is an existing `FRST` direct debit item for this mandate, the items will be
        appended to it.

        :param mandate: the clearing mandate to be used
        :param at: the date at which the invoice items should be collected
        :param description:the description as it will appear to the debtor
        :param invoice_items: a list with invoice items
        :return: the DirectDebitItem
        """
        for direct_debit_item in self.composed_of:
            if (direct_debit_item.mandated_by==mandate) and (direct_debit_item.sequence_type=='FRST'):
                break
        else:
            direct_debit_item = self.append_item(mandate, at, description)
        for invoice_item in invoice_items:
            open_amount = invoice_item.get_open_amount()
            if open_amount != 0:
                DirectDebitInvoice(of=invoice_item,
                                   via=direct_debit_item,
                                   amount=open_amount)
        return direct_debit_item

    def direct_debit_item_for(self, invoice_item):
        """
        :return: the DirectDebitItem in this batch that holds the invoice_item,
            `None` if this invoice item is not in this batch
        """
        for direct_debit_item in self.composed_of:
            for direct_debit_invoice in direct_debit_item.collection_of:
                if direct_debit_invoice.of == invoice_item:
                    return direct_debit_item

    def generate_details(self):
        """
        :return: an iterator over direct_debit_detail objects
        """
        for direct_debit_item in self.composed_of:
            if not len(direct_debit_item.collection_of):
                continue
            mandate = direct_debit_item.mandated_by
            if direct_debit_item.amount <= 0:
                raise UserException('Item with 0 or negative total amount')
            if not mandate.is_valid():
                raise UserException('Mandate {0.id} : {0.identification} is invalid'.format(mandate))
            bic = None
            if mandate.bank_identifier_code:
                bic = mandate.bank_identifier_code.code
            original_mandate_id = None
            if mandate.modification_of is not None:
                original_mandate_id = mandate.modification_of.get_identification()
            yield direct_debit_detail(end_to_end_id = direct_debit_item.id,
                                      amount = direct_debit_item.amount,
                                      bic = bic,
                                      iban = validation.electronic_iban(mandate.iban),
                                      remark_1 = direct_debit_item.item_description[:140],
                                      remark_2 = direct_debit_item.get_debtor_identification()[:140],
                                      mandate_id = mandate.get_identification(),
                                      mandate_signature_date = mandate.date,
                                      mandate_sequence_type = direct_debit_item.sequence_type,
                                      debtor_name = direct_debit_item.get_debtor_name()[:140],
                                      collection_date = max(self.spildatum, direct_debit_item.request_at),
                                      original_mandate_id = original_mandate_id)

    class Admin(BankStatusAdmin, VfinanceAdmin):

        def get_depending_objects(self, obj):
            for direct_debit_item in obj.composed_of:
                yield direct_debit_item
                for direct_debit_invoice in direct_debit_item.collection_of:
                    yield direct_debit_invoice

        verbose_name = _('Direct Debit Batch')
        verbose_name_plural = _('Direct Debit Batches')
        list_display =  ['id', 'batch', 'described_by', 'datum_opmaak', 'spildatum', 'referentie', 'current_status', 'export', 'item_count']
        list_filter = BankStatusAdmin.list_filter + ['batch', 'described_by']
        form_state = 'maximized'
        form_display =  forms.TabForm([(_('Direct Debit'), forms.Form(['batch', 'described_by', 
                                                                       'datum_opmaak','spildatum',
                                                                       'referentie','export',
                                                                       'current_status',
                                                                       'composed_of',], columns=2)),
                                       (_('Status'), ['status']),
                                       ])
        form_actions = tuple(itertools.chain(status_form_actions, (ExportDirectDebitBatch(), CloseDirectDebitBatch(), NewDirectDebitBatch(),)))
        field_attributes = {
                            'name':{'editable':False, 'delegate':delegates.FloatDelegate, 'name':_('Name')},
                            'mededeling1':{'editable':True, 'name':_('Mededeling lijn 1')},
                            'referentie':{'editable':True, 'name':_('Referentie')},
                            'spildatum':{'editable':True, 'name':_('Spildatum')},
                            'datum_opmaak':{'editable':True, 'name':_('Datum van opmaak')},
                            'described_by': {'name':_('Type')},
                           }

@event.listens_for(orm.Session, 'after_attach')
def set_status(session, instance, status=None):
    """Set the status of a new direct debit batch to draft"""
    if isinstance(instance, DirectDebitBatch):
        if instance.current_status is None or status is not None:
            today = datetime.date.today()
            instance._status_history(status_for=instance,
                                     classified_by=status or 'draft',
                                     status_from_date=today,
                                     status_thru_date=party.end_of_times(),
                                     from_date=today,
                                     thru_date=party.end_of_times())

class ChangeDirectDebitItemStatus(Action):
    
    def __init__(self, new_status, verbose_name):
        self.new_status = new_status
        self.verbose_name = verbose_name
        
    def model_run(self, model_context):
        with model_context.session.begin():
            for i,item in enumerate(model_context.get_selection()):
                item.change_status(self.new_status)
                yield action_steps.UpdateProgress(i, model_context.selection_count)
            yield action_steps.FlushSession(model_context.session)

class DirectDebitItem(Entity):
    using_options(tablename='bank_direct_debit_item', order_by=['id'])
    part_of_id = schema.Column(sqlalchemy.types.Integer(),
                               schema.ForeignKey(DirectDebitBatch.id,ondelete='restrict', onupdate='cascade'),
                               nullable=False)
    part_of = orm.relationship(DirectDebitBatch,
                               backref=orm.backref('composed_of', cascade='all,delete-orphan'))
    mandated_by = ManyToOne(DirectDebitMandate,
                            onupdate='cascade', ondelete='restrict',
                            nullable=False)
    sequence_type = schema.Column(camelot.types.Enumeration(direct_debit_sequence_types), nullable=False)
    # sepa requires at least 1 character, and max 140 characters
    item_description = schema.Column(sqlalchemy.types.Unicode(140), nullable=False)
    request_at = schema.Column(sqlalchemy.types.Date(), nullable=False)
    status = schema.Column(camelot.types.Enumeration(direct_debit_result_types), nullable=False, default='pending')

    @property
    def iban(self):
        if self.mandated_by is not None:
            return self.mandated_by._iban

    @property
    def identification(self):
        if self.mandated_by is not None:
            return self.mandated_by.get_identification()
    @property
    def customer_number(self):
        for direct_debit_invoice in self.collection_of:
            return direct_debit_invoice.get_customer_number_at(self.request_at)
        
    @property
    def amount(self):
        return sum((invoice.amount for invoice in self.collection_of), 0)
    
    def get_debtor_identification(self):
        for direct_debit_invoice in self.collection_of:
            return direct_debit_invoice.get_debtor_identification()
        raise UserException('Empty direct debit item {0.id}'.format(self))
    
    def get_debtor_name(self):
        for direct_debit_invoice in self.collection_of:
            return direct_debit_invoice.get_debtor_name()
        raise UserException('Empty direct debit item {0.id}'.format(self))

    def change_status(self, new_status):
        if self.part_of.current_status != 'verified':
            raise UserException('Direct debit batch is not in verified status')
        self.status = new_status

    class Admin(BankRelatedStatusAdmin):

        def get_status(self, obj):
            if  obj.part_of is  not None:
                return obj.part_of.current_status

        def get_related_toolbar_actions(self, toolbar_area, direction):
            actions = BankRelatedStatusAdmin.get_related_toolbar_actions(self, toolbar_area, direction)
            actions.append( ChangeDirectDebitItemStatus('accepted', _('Accept') ) )
            actions.append( ChangeDirectDebitItemStatus('rejected', _('Reject') ) )
            return actions

        verbose_name = _('Direct debit item')
        list_display = ['id', 'request_at', 'sequence_type', 'item_description', 'amount', 'iban', 'identification', 'status', 'customer_number']
        form_display = list_display + ['mandated_by', 'collection_of']
        field_attributes =  {'amount': {'delegate':  delegates.FloatDelegate},
                             'status': {'editable':False},
                             'id': {'editable': False, 'name': 'End to End Id'}
                             }

DirectDebitBatch.item_count = orm.column_property(sql.select([sql.func.count(DirectDebitItem.id)]).where(DirectDebitItem.part_of_id==DirectDebitBatch.id), deferred=True)

class DirectDebitInvoice(Entity):
    using_options(tablename='bank_direct_debit_invoice', order_by=['id'])
    of_id = schema.Column(sqlalchemy.types.Integer(),
                          schema.ForeignKey(InvoiceItem.id, ondelete='restrict', onupdate='cascade'),
                          nullable=False)
    of = orm.relationship(InvoiceItem,
                          backref=orm.backref('collected_via'))
    via_id = schema.Column(sqlalchemy.types.Integer(),
                          schema.ForeignKey(DirectDebitItem.id, ondelete='restrict', onupdate='cascade'),
                          nullable=False)
    via = orm.relationship(DirectDebitItem,
                          backref=orm.backref('collection_of', cascade='all, delete-orphan'))
    amount = schema.Column(sqlalchemy.types.Numeric(precision=17, scale=2), nullable=False)

    @property
    def doc_date(self):
        if self.of is not None:
            return self.of.doc_date

    @property
    def item_description(self):
        if self.of is not None:
            return self.of.item_description

    @property
    def request_at(self):
        if self.via is not None:
            return self.via.request_at

    @property
    def current_status(self):
        if self.via is not None:
            if self.via.part_of is not None:
                return self.via.part_of.current_status

    def get_debtor_identification(self):
        """
        :return: the identification that is used to communicate with the debtor
        """
        invoice_item = self.of
        if invoice_item is not None:
            if invoice_item.dossier is not None:
                return str(invoice_item.dossier.full_number)
            elif invoice_item.premium_schedule is not None:
                return invoice_item.premium_schedule.agreement_code

    def get_customer_number_at(self, doc_date):
        """
        :return: the customer number
        """
        invoice_item = self.of
        if invoice_item is not None:
            if invoice_item.dossier is not None:
                return str(invoice_item.dossier.customer_number)

    def get_debtor_name(self):
        invoice_item = self.of
        if invoice_item is not None:
            if invoice_item.dossier is not None:
                return unicode(invoice_item.dossier.borrower_1_name)
            elif invoice_item.premium_schedule is not None:
                return unicode(invoice_item.premium_schedule.subscriber_1)

    class Admin(BankRelatedStatusAdmin):

        def get_status(self, obj):
            return obj.current_status

        def get_depending_objects(self, obj):
            yield obj.of
            yield obj.via

        verbose_name = ('Direct debit invoice')
        list_display = ['doc_date', 'item_description', 'amount']
        form_display = list_display + ['of']
        field_attributes = {'doc_date': {'delegate': delegates.DateDelegate,},
                            'request_at': {'delegate': delegates.DateDelegate,},
                            }

    class InvoiceItemAdmin(Admin):
        list_display = ['request_at', 'amount', 'current_status']

InvoiceItem.Admin.field_attributes['collected_via'] = {'admin': DirectDebitInvoice.InvoiceItemAdmin,}

ddi_table = sql.alias(DirectDebitItem.__table__)
ddinv_table = sql.alias(DirectDebitInvoice.__table__)

last_direct_debit_item_select = sql.select([],
                                           from_obj=ddi_table.join(ddinv_table,
                                                                   ddinv_table.c.via_id==ddi_table.c.id),
                                           whereclause=ddinv_table.c.of_id==InvoiceItem.id,
                                           order_by=[ddi_table.c.id.desc()],
                                           limit=1,
                                          )

InvoiceItem.last_direct_debit_request_at = orm.column_property(last_direct_debit_item_select.column(ddi_table.c.request_at), deferred=True)
InvoiceItem.last_direct_debit_batch_id = orm.column_property(last_direct_debit_item_select.column(ddi_table.c.part_of_id), deferred=True)
